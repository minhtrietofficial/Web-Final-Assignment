(function (max) {
  'use strict';

  var e={},n=[],r=e=>e,t=n.map,l=Array.isArray,o="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:setTimeout,i=e=>{var n="";if("string"==typeof e)return e;if(l(e))for(var r,t=0;t<e.length;t++)(r=i(e[t]))&&(n+=(n&&" ")+r);else for(var t in e)e[t]&&(n+=(n&&" ")+t);return n},a=(e,n)=>{for(var r in {...e,...n})if("function"==typeof(l(n[r]=e[r])?n[r][0]:n[r]));else if(e[r]!==n[r])return !0},u=e=>null==e?e:e.key,d=(e,n,r,t,l,o)=>{if("key"===n);else if("style"===n)for(var a in {...r,...t})r=null==t||null==t[a]?"":t[a],"-"===a[0]?e[n].setProperty(a,r):e[n][a]=r;else "o"===n[0]&&"n"===n[1]?((e.tag||(e.tag={}))[n=n.slice(2)]=t)?r||e.addEventListener(n,l):e.removeEventListener(n,l):!o&&"list"!==n&&"form"!==n&&n in e?e[n]=null==t?"":t:null==t||!1===t||"class"===n&&!(t=i(t))?e.removeAttribute(n):e.setAttribute(n,t);},f=(e,n,r)=>{var t=e.props,l=3===e.tag?document.createTextNode(e.type):(r=r||"svg"===e.type)?document.createElementNS("http://www.w3.org/2000/svg",e.type,{is:t.is}):document.createElement(e.type,{is:t.is});for(var o in t)d(l,o,null,t[o],n,r);for(var i=0;i<e.children.length;i++)l.appendChild(f(e.children[i]=p(e.children[i]),n,r));return e.node=l},s=(e,n,r,t,l,o)=>{if(r===t);else if(null!=r&&3===r.tag&&3===t.tag)r.type!==t.type&&(n.nodeValue=t.type);else if(null==r||r.type!==t.type)n=e.insertBefore(f(t=p(t),l,o),n),null!=r&&e.removeChild(r.node);else {var i,a,m,v,y=r.props,c=t.props,h=r.children,g=t.children,x=0,w=0,C=h.length-1,k=g.length-1;for(var A in o=o||"svg"===t.type,{...y,...c})("value"===A||"selected"===A||"checked"===A?n[A]:y[A])!==c[A]&&d(n,A,y[A],c[A],l,o);for(;w<=k&&x<=C&&null!=(m=u(h[x]))&&m===u(g[w]);)s(n,h[x].node,h[x],g[w]=p(g[w++],h[x++]),l,o);for(;w<=k&&x<=C&&null!=(m=u(h[C]))&&m===u(g[k]);)s(n,h[C].node,h[C],g[k]=p(g[k--],h[C--]),l,o);if(x>C)for(;w<=k;)n.insertBefore(f(g[w]=p(g[w++]),l,o),(a=h[x])&&a.node);else if(w>k)for(;x<=C;)n.removeChild(h[x++].node);else {var N={},E={};for(A=x;A<=C;A++)null!=(m=h[A].key)&&(N[m]=h[A]);for(;w<=k;)m=u(a=h[x]),v=u(g[w]=p(g[w],a)),E[m]||null!=v&&v===u(h[x+1])?(null==m&&n.removeChild(a.node),x++):null==v||1===r.tag?(null==m&&(s(n,a&&a.node,a,g[w],l,o),w++),x++):(m===v?(s(n,a.node,a,g[w],l,o),E[v]=!0,x++):null!=(i=N[v])?(s(n,n.insertBefore(i.node,a&&a.node),i,g[w],l,o),E[v]=!0):s(n,a&&a.node,null,g[w],l,o),w++);for(;x<=C;)null==u(a=h[x++])&&n.removeChild(a.node);for(var A in N)null==E[A]&&n.removeChild(N[A].node);}}return t.node=n},p=(e,n)=>!0!==e&&!1!==e&&e?"function"==typeof e.tag?((!n||null==n.memo||((e,n)=>{for(var r in e)if(e[r]!==n[r])return !0;for(var r in n)if(e[r]!==n[r])return !0})(n.memo,e.memo))&&((n=e.tag(e.memo)).memo=e.memo),n):e:text(""),m=n=>3===n.nodeType?text(n.nodeValue,n):v(n.nodeName.toLowerCase(),e,t.call(n.childNodes,m),n,null,1),v=(e,n,r,t,l,o)=>({type:e,props:n,children:r,node:t,key:l,tag:o});var text=(r,t)=>v(r,e,n,t,null,3);var h=(e,r,t)=>v(e,r,l(t)?t:null==t?n:[t],null,r.key);var app=e=>{var n,t,i=e.view,u=e.node,d=e.subscriptions,f=u&&m(u),p=[],v=e=>{t!==e&&(t=e,d&&(p=((e,n,r)=>{for(var t,l,o=[],i=0;i<e.length||i<n.length;i++)t=e[i],l=n[i],o.push(l&&!0!==l?!t||l[0]!==t[0]||a(l[1],t[1])?[l[0],l[1],l[0](r,l[1]),t&&t[2]()]:t:t&&t[2]());return o})(p,d(t),y)),i&&!n&&o(h,n=!0));},y=(e.middleware||r)((e,n)=>"function"==typeof e?y(e(t,n)):l(e)?"function"==typeof e[0]?y(e[0],e[1]):e.slice(1).map(e=>e&&!0!==e&&e[0](y,e[1]),v(e[0])):v(e)),c=function(e){y(this.tag[e.type],e);},h=()=>u=s(u.parentNode,u,f,f=i(t),c,n=!1);y(e.init);};

  function dispatchEventEffect(t,{eventType:e,eventInit:n}){const s=new CustomEvent(e,n);this.dispatchEvent(s);}function setOnEventListenerEffect(t,{eventType:e,oldVal:n,newVal:s}){null!==n&&this.removeEventListener(e,n),null!==s&&this.addEventListener(e,s);}function t$1({app:t,state:e,init:n,view:s,subscriptions:i,middleware:o,exposedConfig:r=[],exposedMethods:a={},useShadowDOM:c=!0,parent:p=HTMLElement}){const[u,l]=function(){const t=new Map,e=new Map;for(const n of r)n.propName&&t.set(n.propName,n),n.attrName&&e.set(n.attrName.toLowerCase(),n),"function"!=typeof n.setter&&(n.setter=n.eventType?d(n):PatchState);return [t,e]}();class CustomElement extends p{constructor(){super();const r=(c?this.attachShadow({mode:"open"}):this._fragment=document.createDocumentFragment()).appendChild(document.createElement("span"));e&&(n=e,console.warn('Passing "state" is deprecated. Pass "init" instead'));const a=this.wrapDispatch.bind(this);var p,u;"function"==typeof o?(p=a,u=o,o=function(t){return p(u(t))}):o=a,t({init:n,view:s,subscriptions:i,middleware:o,node:r});}connectedCallback(){c||p!==HTMLElement||this.appendChild(this._fragment);}disconnectedCallback(){this._dispatch=void 0;}wrapDispatch(t){const e=t=>{const e=t.bind(this);return t.$isWrapped&&(e.$isWrapped=!0),e};return this._dispatch=t,(n,s)=>{let i;if("function"==typeof n)n=e(n);else if(Array.isArray(n))if("function"==typeof n[0])n[0]=e(n[0]);else {i=n[0];for(let t=1;t<n.length;t++){const s=n[t];s[0]=e(s[0]);}}else i=n;void 0!==i&&(this._state=i),t(n,s),void 0!==i&&this.syncAttributes();}}dispatchAction(t,e){this._dispatch(t,e);}syncAttributes(){for(const t in this._state)if(u.has(t)){const e=u.get(t);e.attrName&&this.syncAttribute(e,this._state[t]);}}syncAttribute(t,e){if(t.eventType)return;const n=t.attrName;"boolean"==typeof e?e?this.setAttribute(n,""):this.removeAttribute(n):null==e||""===e?this.removeAttribute(n):this.setAttribute(n,e);}getProperty(t){return (u.get(t).getter||(e=>e?.[t]))(this._state)}setProperty(t,e){const n=u.get(t).setter;this.dispatchAction(n,{[t]:e});}attributeChangedCallback(t,e,n){if(e===n)return;const s=l.get(t.toLowerCase()),i=s.setter,o=s.propName||s.attrName;(""===n&&null===e||null===n&&""===e||null===n&&e===t||n===t&&null===e)&&(n=!(null===n)),this.dispatchAction(i,{[o]:n});}static get observedAttributes(){return l.keys()}}function PatchState(t,e){return {...t,...e}}function d({propName:t,attrName:e,eventType:n}){return function SetOnEventHandler(s,i){const o=t||e;let r=i[o];r&&"function"!=typeof r&&(r=new Function("event",r),Object.defineProperty(r,"name",{value:o}));const a=s[o];return [{...s,[o]:r},[setOnEventListenerEffect,{eventType:n,oldVal:a,newVal:r}]]}}return u.forEach((t,e)=>{const n={configurable:!1,enumerable:!0,get(){return this.getProperty(e)},set(t){this.setProperty(e,t);}};Object.defineProperty(CustomElement.prototype,e,n);}),function(){for(const t in a)CustomElement.prototype[t]=function(){this.dispatchAction(a[t]);};}(),CustomElement}

  function eventSubscriber(dispatch, { target, eventType, action }) {
    target = target || window;

    target.addEventListener(eventType, handleEvent);

    return () => {
      target.removeEventListener(eventType, handleEvent);
    };

    function handleEvent(event) {
      dispatch([action, event]);
    }
  }

  /**
   * Effect that initialises a native element's built-in properties.
   */
  function initNativeProperties(_, props) {
    for (const propName in props) {
      this[propName] = props[propName];
    }
  }

  /**
   * Sets the native input control's validity status. This affects the :valid and
   * :invalid CSS pseudo-classes and form validation.
   *
   * @param {function} dispatch
   * @param {Object} props
   * @param {HTMLInputElement} props.input The input element instance.
   * @param {boolean} props.isValid Whether the value is considered valid.
   * @param {string} props.errorMsg An error message that will be displayed when
   *    the form is validated by the browser prior to submission.
   */
  function setValidity(dispatch, { input, isValid, errorMsg }) {
    input.setCustomValidity(isValid ? '' : errorMsg);
  }

  /**
   * The default number of milliseconds to wait before invoking an action.
   */
  const DEFAULT_INTERVAL = 250;

  /**
   * Creates a debounced version of an original Hyperapp action.
   *
   * Strategy:
   * 1. Construct and return an action that does nothing but trigger an effect.
   * 2. Configure the effect to dispatch the original action after the specified
   *    interval.
   *
   * @param {function} action The action to invoke in a debounced way.
   * @param {number} [interval] The number of milliseconds to wait for another
   *    invocation before triggering the action.
   * @returns {function} a replacement action.
   */
  function debounce(action, interval = DEFAULT_INTERVAL) {
    return function (state, props) {
      const effect = [debounceEffect, { action, props, interval }];
      return [state, effect];
    };
  }

  /**
   * A map of currently scheduled timeouts. The keys of the map are the Action
   * functions for which timeouts are scheduled. Having objects as keys is a very
   * convenient property of WeakMaps.
   */
  const pendingTimeouts = new WeakMap();

  /**
   * This function is a Hyperapp effect that invokes an action after a specified
   * interval. The interval is restarted if the effect is invoked again for the
   * same action before the action itself has been invoked.
   *
   * Strategy:
   * 1. The first time this is called for a specific action, set a timeout.
   * 2. Maintain a map of pending timeouts, indexed by action.
   * 3. On subsequent calls for the same action, restart the timeout if it hasn't
   *    yet fired.
   *
   * @param {function} dispatch
   * @param {Object} props
   * @param {function} props.action The action to dispatch after the interval.
   * @param {*} props.payload The argument to call the action with.
   * @param {number} props.interval The interval (milliseconds) after which to
   *    dispatch the action.
   */
  function debounceEffect(dispatch, { action, props, interval }) {
    // If the action has already been scheduled, restart the interval.
    cancelAction(action);

    const handle = setTimeout(() => {
      pendingTimeouts.delete(action);
      dispatch(action, props);
    }, interval);

    pendingTimeouts.set(action, handle);
  }

  /**
   * Cancels a specific pending action. This should be done when a state change
   * means that it would be inappropriate to follow through with the specific
   * pending action that was submitted before the state change.
   *
   * @param {function} action The action to cancel.
   */
  function cancelAction(action) {
    const handle = pendingTimeouts.get(action);
    if (handle) {
      clearTimeout(handle);
      pendingTimeouts.delete(action);
    }
  }

  const PARSE = 'phone-parse';
  const COUNTRY_CHANGE = 'phone-country-change';

  const INPUT_DEBOUNCE_INTERVAL = 250;
  const ERROR_INVALID_PHONE_NUMBER = 'Invalid phone number!';

  const E164 = 'E.164';

  /**
   * Parses and validates the supplied phone number, then dispatches the specified
   * action.
   *
   * @param {function} dispatch
   * @param {Object} props
   * @param {string} props.defaultCountry
   * @param {string} props.value The phone number that needs to be parsed.
   * @param {function} props.action The action to dispatch.
   */
  function parsePhoneNumber(dispatch, { defaultCountry, value, action }) {
    // Attempt to parse the phone number.
    const phone = max.parsePhoneNumberFromString(value, defaultCountry);

    const parsed = {
      country: phone?.country,
      phoneIsPossible: phone?.isPossible() || false,
      phoneIsValid: phone?.isValid() || false,
      phoneType: phone?.getType(),
      phoneE164: phone?.format(E164),
    };

    dispatch(action, parsed);
  }

  /**
   * Effect that adds spaces or hyphens at appropriate places as the number is
   * being entered.
   *
   * @param {function} dispatch
   * @param {Object} props
   * @param {string} props.defaultCountry The 2-letter code of the default country
   * @param {HTMLInputElement} props.input The input element instance.
   */
  function formatPhoneNumber(dispatch, { defaultCountry, input }) {
    // Determine the appropriate formatting for the number as entered so far.
    const formatted = new max.AsYouType(defaultCountry).input(input.value);

    if (input.value !== formatted) {
      // Punctuation is about to be added. If the cursor is not at the end of the
      // input field, it will jump to the end. We therefore have to save and
      // restore its position.
      const start = input.selectionStart;
      const end = input.selectionEnd;
      const shouldMoveCursor = start !== input.value.length;

      input.value = formatted;

      if (shouldMoveCursor) {
        input.setSelectionRange(start, end);
      }
    }
  }

  /**
   * Creates and configures an effect tuple that will set the native element's
   * validity status.
   *
   * @param {Object} props The properties are named so that the current state can
   *    be passed in.
   * @param {HTMLInputElement} props.self
   * @param {boolean} props.phoneIsValid
   * @param {string} props.errorMsg
   */
  function createSetValidityEffect({ self, phoneIsValid, errorMsg }) {
    return [
      setValidity,
      {
        input: self,
        isValid: phoneIsValid,
        errorMsg: errorMsg || ERROR_INVALID_PHONE_NUMBER,
      },
    ];
  }

  /**
   * Initialises the element.
   *
   * @param {Object} state
   * @returns {Array}
   */
  function InitialiseState(state = {}) {
    // We add a reference to the element itself so that subscriber functions can
    // easily use it as a target for registering event listeners.
    const newState = {
      ...state,
      self: this,
    };

    // Set the native field's type to "tel" so that the mobile keyboard
    // adapts to show only digits.
    const effect = [initNativeProperties, { type: 'tel' }];

    return [newState, effect];
  }

  /**
   * Sets the default country to use when parsing the phone number.
   *
   * @param {Object} state
   * @param {Object} props
   * @param {string} props.defaultCountry
   * @returns {Array}
   */
  function SetDefaultCountry(state, { defaultCountry }) {
    const newState = {
      ...state,
      defaultCountry,
    };

    // When the default country changes, we need to reprocess the current number.
    return [
      newState,
      [
        parsePhoneNumber,
        { defaultCountry, value: newState.self.value, action: UpdatePhoneNumber },
      ],
    ];
  }

  /**
   * Sets the error message for the browser to display when validating forms that
   * include this component.
   *
   * @param {Object} state
   * @param {Object} props
   * @param {string} props.errorMsg The error message.
   * @returns {Array}
   */
  function SetErrorMessage(state, { errorMsg }) {
    const newState = { ...state, errorMsg };

    // When changing the error message, the native validity needs to be reset,
    // because the error message itself is used as a validity flag by the native
    // element.
    const effect = createSetValidityEffect(state);

    return [newState, effect];
  }

  /**
   * Action that triggers parsing of the number that has been entered so far.
   *
   * @param {Object} state
   * @param {InputEvent} event
   * @returns {Array}
   */
  function HandleInput(state, event) {
    return [
      state,
      [
        parsePhoneNumber,
        {
          defaultCountry: state.defaultCountry,
          value: event.target.value,
          action: UpdatePhoneNumber,
        },
      ],
    ];
  }

  // Create a debounced version of HandleInput.
  const DebouncedInput = debounce(HandleInput, INPUT_DEBOUNCE_INTERVAL);

  /**
   * Updates the state with the results of parsing and validating the contents of
   * the element. Using effects, causes the native element's validity status to be
   * updated, and reformats the punctuation of the number in the element.
   *
   * @param {Object} state
   * @param {Object} props
   * @param {string} props.country
   * @param {boolean} props.phoneIsPossible
   * @param {boolean} props.phoneIsValid
   * @param {string} props.phoneType
   * @param {string} props.phoneE164
   * @returns {Array}
   */
  function UpdatePhoneNumber(state, props) {
    const newState = { ...state, ...props };

    const effects = [
      createSetValidityEffect(newState),
      [
        formatPhoneNumber,
        { defaultCountry: newState.defaultCountry, input: newState.self },
      ],
      // Tell listeners that the number has been parsed.
      [dispatchEventEffect, { eventType: PARSE }],
    ];

    // If the country has changed, add an effect that will dispatch an event.
    if (state.country !== newState.country) {
      effects.push([
        dispatchEventEffect,
        {
          eventType: 'phone-country-change',
          eventInit: { detail: newState.country },
        },
      ]);
    }

    return [newState, ...effects];
  }

  /**
   * Returns an array of subscriptions.
   * We need to catch the `input` events dispatched by the native InputElement
   * functionality.
   *
   * @param {Object} state
   * @returns {Array.<[function, Object]>}
   */
  function subscriptions(state) {
    return [
      [
        eventSubscriber,
        {
          target: state.self,
          eventType: 'input',
          action: DebouncedInput,
        },
      ],
    ];
  }

  const PhoneNumberInput = t$1({
    app,
    init: [InitialiseState, {}],
    view: () => h('span', {}),
    subscriptions,
    exposedConfig: [
      {
        propName: 'defaultCountry',
        attrName: 'default-country',
        setter: SetDefaultCountry,
      },
      {
        propName: 'errorMsg',
        attrName: 'error-msg',
        setter: SetErrorMessage,
      },
      {
        propName: 'phoneIsValid',
        attrName: 'phone-is-valid',
      },
      {
        propName: 'phoneIsPossible',
        attrName: 'phone-is-possible',
      },
      {
        propName: 'country',
        attrName: 'country',
      },
      {
        propName: 'phoneType',
        attrName: 'phone-type',
      },
      {
        propName: 'phoneE164',
        attrName: 'phone-e164',
      },
      {
        propName: 'onparse',
        attrName: 'onparse',
        eventType: PARSE,
      },
      {
        propName: 'oncountrychange',
        attrName: 'oncountrychange',
        eventType: COUNTRY_CHANGE,
      },
    ],
    useShadowDOM: false,
    parent: HTMLInputElement,
  });

  customElements.define('phone-number-input', PhoneNumberInput, {
    extends: 'input',
  });

}(libphonenumber));
